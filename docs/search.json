[
  {
    "objectID": "Assessment.html",
    "href": "Assessment.html",
    "title": "stc_assessment",
    "section": "",
    "text": "library(tidyverse)\nlibrary(Hmisc)\nlibrary(waldo)\nlibrary(matrixStats) # I used this package to calucate the weighted median \nlibrary(DT)\nlibrary(rmarkdown)\n#### Set up the Url to download the raw data \ntag      &lt;- \"202311081903\"\nbase_url &lt;- \"https://github.com/randrescastaneda/pub_data/raw/\"\ndata_url &lt;- paste0(base_url, tag, \"/data/Rtest1/\")\n\n## Download the raw data set for taks 1-3\nwdi &lt;- readr::read_rds(paste0(data_url, \"wdi_in1.Rds\"))\n\n\n1. Summary statistics of GDP per capita by region\nThe replicated results in this task are almost identical to the original results.\n\n############################################################\n### 1. Summary statistics of GDP per capita by region      #\n############################################################\nq1_rep &lt;- wdi%&gt;%\n  group_by(region, date)%&gt;%\n  summarise(N = n(), Mean = weighted.mean(gdp, pop, na.rm = TRUE),\n            SD = sqrt(wtd.var(gdp, pop,na.rm = TRUE)),\n            Min = min(gdp, na.rm = TRUE), Max = max(gdp, na.rm = TRUE))%&gt;%\n  rename(year = date)%&gt;%\n  as.data.frame()\n\n## Display the output \ndatatable(q1_rep, options = list(pageLength = 10), filter = \"top\")\n\n\n\n\n\n\n\n\n2. Aggregate stats\nThe replicated results in this task are pretty close to the original outputs except for the median. I tried to estimate the weighted median using an existing function, but the estimates are off.\n\n############################################\n### 2. Aggregate stats                     #     \n############################################\n# List the relevant variables\nvars &lt;- c(\"lifeex\", \"gdp\", \"pov_intl\")\n\n# Initialize a list to store the results \nresult &lt;- list()\n\n## Loop over the selected variables \nfor (var in vars){\n q2_rep &lt;- wdi%&gt;%\n    group_by(region, date)%&gt;%\n    summarise(mean = weighted.mean(!!sym(var), pop, na.rm = TRUE),\n              sd = sqrt(wtd.var(!!sym(var), pop,na.rm = TRUE)),\n              median = weightedMedian(!!sym(var), pop),\n              pop = sum(pop, na.rm = TRUE),\n              min = min(!!sym(var), na.rm = TRUE), \n              max = max(!!sym(var), na.rm = TRUE))%&gt;%\n    gather(\"estimate\", !!var, -c(pop, region, date))\n result[[var]] &lt;- q2_rep\n}\n\n## Combine the outputs to generate the final tables \nq2_rep &lt;- Reduce(function(x, y) merge(x, y, by = c(\"region\", \"date\", \"estimate\", \"pop\"), \n                                      all = TRUE), result)%&gt;%\n  as.data.frame()\n\n## Display the output \ndatatable(q2_rep, options = list(pageLength = 10), filter = \"top\")\n\n\n\n\n\n## Download the answer table\n#wdi_agg_out &lt;- readr::read_rds(paste0(data_url, \"wdi_agg_out.Rds\"))%&gt;%\n  #as.data.frame()\n\n\n\n3. Find outliers\nThe replicated results are pretty close to the original outputs.\n\n############################################\n### 3. Find outliers                       #\n############################################\n\nq3_rep &lt;- wdi%&gt;%\n  group_by(date)%&gt;%\n  mutate(mean_lifeex = weighted.mean(lifeex, pop, na.rm = TRUE),\n         sd_lifeex = sqrt(wtd.var(lifeex, pop, na.rm = TRUE)),\n         hl_lifeex = lifeex &gt; mean_lifeex+2.5*sd_lifeex,\n         ll_lifeex = lifeex &lt; mean_lifeex-2.5*sd_lifeex)%&gt;%\n  mutate(mean_gdp = weighted.mean(gdp, pop, na.rm = TRUE),\n         sd_gdp = sqrt(wtd.var(gdp, pop, na.rm = TRUE)),\n         hl_gdp = gdp &gt; mean_gdp+2.5*sd_gdp,\n         ll_gdp = gdp &lt; mean_gdp-2.5*sd_gdp)%&gt;%\n  mutate(mean_gini = weighted.mean(gini, pop, na.rm = TRUE),\n         sd_gini = sqrt(wtd.var(gini, pop, na.rm = TRUE)),\n         hl_gini = gini &gt; mean_gini+2.5*sd_gini,\n         ll_gini = gini &lt; mean_gini-2.5*sd_gini)\n\n## Display the output \ndatatable(q3_rep, options = list(pageLength = 10), filter = \"top\")\n\n\n\n\n\n## Visualize life-expectancy by year\nq3_rep%&gt;%\n  group_by(date)%&gt;%\n  ggplot(aes(date,lifeex, mean_lifeex, col = region))+\n  geom_point()+\n  geom_line(aes(date, mean_lifeex), col = \"blue\", size = 0.7)+\n  geom_ribbon(aes( ymin = mean_lifeex-2.5*sd_lifeex, ymax = mean_lifeex+2.5*sd_lifeex), \n              fill = \"grey\", color = NA, alpha = 0.6)+\n  theme_minimal()+\n  theme(legend.position = c(0.5, 0.16))+\n  theme(legend.title = element_blank())+\n  guides(color = guide_legend(ncol = 4, byrow = TRUE))\n\n\n\n\n\n\n4. Poverty Measure\nThe replicated results are almost identical to the original outputs.\n\n#######################################\n### 4. Poverty Measure                #\n#######################################\n## Read the raw data from github \nl_svy &lt;- readr::read_rds(paste0(data_url, \"svy_sim_in1.Rds\"))\n\n### Convert the list into a data frame \n## Add a year column\nl_svy &lt;- lapply(names(l_svy), function(year) {\n  df &lt;- l_svy[[year]]\n  df$year &lt;- year\n  return(df)\n})\n\n## combine by row\nsim_data &lt;- do.call(rbind, l_svy)%&gt;%\n  mutate(year = str_sub(year,2,5))%&gt;%\n  as.data.frame()\n\n## The setup of the output file \n# Poverty lines \npov_lines &lt;- c(2.15, 3.65, 6.85)\n\n## Initialize a data frame to store the results\nq4_rep &lt;- expand.grid(year = unique(sim_data$year), pov_line = pov_lines)\nq4_rep &lt;- q4_rep%&gt;%\n  mutate(headcount = NA, povgap = NA, povseverity = NA)\n\n## Write a customized function to compute the poverty indices \npov_func &lt;- function(income, pov_line, w, alpha){\n  data &lt;- data.frame(income, pov_line, w)\n  data &lt;- data%&gt;%\n    mutate(diff = ifelse(income &lt; pov_line,((pov_line-income)/pov_line),0),\n           pov_ind = ifelse(income &lt; pov_line, diff^alpha,0))%&gt;%\n    summarise(pov_ind = sum(pov_ind*w),\n              total_weight = sum(w))\n  data$pov_ind/data$total_weight\n}\n## Compute poverty headcount, poverty gap, and poverty severity \nfor (i in 1:nrow(q4_rep)){\n  reduced_data &lt;- sim_data%&gt;%filter(year == q4_rep$year[i])\n  q4_rep$headcount[i] &lt;- pov_func(reduced_data$income, \n                                  pov_line = q4_rep$pov_line[i], \n                                  w = reduced_data$weight,alpha = 0)\n  q4_rep$povgap[i] &lt;- pov_func(reduced_data$income, \n                               pov_line = q4_rep$pov_line[i], \n                               w = reduced_data$weight,alpha = 1)\n  q4_rep$povseverity[i] &lt;- pov_func(reduced_data$income, \n                                    pov_line = q4_rep$pov_line[i], \n                                    w = reduced_data$weight,alpha = 2)\n}\n\n## Display the output \ndatatable(q4_rep, options = list(pageLength = 10), filter = \"top\")\n\n\n\n\n\n## Visualize the head count against year\nq4_rep%&gt;%\n  ggplot(aes(year, headcount, group = pov_line, color = as.factor(pov_line)))+\n  geom_line()+\n  geom_point() +\n  theme_minimal() +\n  theme(legend.title = element_blank())+\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n5. Lorenz curve\nThe replicated results in this task are different from the original output. However, the graph looks pretty similar.\n\n#######################################     \n### 5. Lorenz curve                   #\n#######################################\n# Write a function \nlorenz_curve &lt;- function(x){\n  # Set up an empty data frame\n  q5_rep &lt;- data.frame(\n    welfare = numeric(0),\n    cum_welfare = numeric(0),\n    cum_population = numeric(0),\n    year = integer(0),\n    bin = integer(0)\n  )\n  # Unique number of years \n  years &lt;- unique(x$year)\n  # Looping over each year\n  for (i in seq_along(years)){\n    yrs &lt;- years[i]\n    temp_out &lt;- x %&gt;%\n      filter(year == yrs) %&gt;%\n      arrange(income) %&gt;%\n      mutate(cum_welfare_w = cumsum(income * weight),\n             cum_weight = cumsum(weight)) %&gt;%\n      # Normalizing the cumulative share of income and population\n      mutate(cum_welfare = cum_welfare_w / sum(income * weight),\n             cum_population = cum_weight / sum(weight))%&gt;%\n      select(-c(income, area, weight))\n    # Creating percentiles \n    percentiles &lt;- seq(0, 1, length.out = 100)\n    # Calculating the cumulative welfare for each percentile \n    cum_welfare_percent &lt;- approx(temp_out$cum_population, temp_out$cum_welfare, percentiles)$y\n    # Calculating the welfare for each percentile \n    welfare_percent &lt;- approx(temp_out$cum_population, temp_out$cum_welfare_w, percentiles)$y\n    # Creating a another temporary data frame to update the values of variables created in the temp_out \n    aux_out_table &lt;- data.frame(\n      welfare = welfare_percent,        \n      cum_welfare = cum_welfare_percent,    \n      cum_population = percentiles,     \n      year = rep(yrs, length(percentiles)),    \n      bin = seq(1, 100)                 \n    )\n    # Creating the final output table\n    q5_rep &lt;- rbind(q5_rep, aux_out_table)\n  } \n  # Return the output table\n  return(q5_rep)\n}\n\nq5_rep &lt;- lorenz_curve(sim_data)\n\n## Display the output \ndatatable(q5_rep, options = list(pageLength = 10), filter = \"top\")\n\n\n\n\n\n### Visualize the cumulative share of income against the cumulative share of population \nq5_rep%&gt;%\n  ggplot(aes(cum_population, cum_welfare, group = year, color = as.factor(year)))+\n  geom_line()+\n  theme_minimal() +\n  theme(legend.title = element_blank())+\n  theme(legend.position = c(0.1, 0.55))\n\nWarning: Removed 10 row(s) containing missing values (geom_path).\n\n\n\n\n\n\n\n6. Estimating Gini Coefficient\nThe replicated results are almost identical to the original outputs.\n\n##########################################\n### 6. Estimating Gini Coefficient       #\n##########################################\n\n## Write function that estimate Gini coefficient for each year\ngini_func &lt;- function(x) {\n  # Create an empty data frame to store the estimates\n  q6_rep &lt;- data.frame(year = integer(), gini = numeric())\n  ## loop over the year \n  for (yr in unique(x$year)) {\n    # Prepare the data for estimating the Gini coefficient\n    gini_data &lt;- x %&gt;%\n      filter(year == yr) %&gt;%\n      arrange(income) %&gt;%\n      mutate(cum_weight = cumsum(weight / sum(weight)),\n             cum_income = cumsum(income * weight / sum(income * weight)))\n    # Compute the Gini coefficient\n    G &lt;- 1 - sum(2 * diff(c(0, gini_data$cum_weight)) * c(0, head(gini_data$cum_income, -1)))\n    # Store the yearly estimate of the Gini coefficient\n    q6_rep &lt;- rbind(q6_rep, data.frame(year = yr, gini = G))\n  }\n  return(q6_rep)\n}\n\n## Generate the Gini coefficient by year \nq6_rep &lt;- gini_func(sim_data)\n\n## Display the output \ndatatable(q6_rep, options = list(pageLength = 10), filter = \"top\")\n\n\n\n\n\n## Visualize the estimates of Gini Coefficient by year \nq6_rep%&gt;%\n  ggplot(aes(year, gini, group = FALSE))+\n  geom_line()+\n  geom_point()+\n  theme_minimal()"
  }
]